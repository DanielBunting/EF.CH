using System.Text;
using System.Text.RegularExpressions;

namespace EF.CH.Design.Internal;

/// <summary>
/// Generates C# enum source code from ClickHouse Enum8/Enum16 definitions.
/// </summary>
public partial class ClickHouseEnumCodeGenerator
{
    /// <summary>
    /// Generates C# enum code from a ClickHouse enum definition.
    /// </summary>
    /// <param name="enumTypeName">The name of the C# enum type to generate.</param>
    /// <param name="enumDefinition">The ClickHouse enum definition (e.g., "Enum8('Pending' = 0, 'Shipped' = 1)").</param>
    /// <param name="namespace">The namespace for the generated enum.</param>
    /// <returns>The generated C# source code, or empty string if parsing fails.</returns>
    public string GenerateEnumCode(string enumTypeName, string enumDefinition, string @namespace)
    {
        var members = ParseEnumDefinition(enumDefinition);
        if (members is null || members.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();
        var isEnum8 = enumDefinition.StartsWith("Enum8", StringComparison.OrdinalIgnoreCase);

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Generated by EF.CH scaffolding from ClickHouse enum type.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine($"namespace {@namespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Enum generated from ClickHouse {(isEnum8 ? "Enum8" : "Enum16")} type.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public enum {enumTypeName}");
        sb.AppendLine("{");

        for (int i = 0; i < members.Count; i++)
        {
            var (name, value) = members[i];
            var sanitizedName = SanitizeEnumMemberName(name);
            var comma = i < members.Count - 1 ? "," : "";

            if (sanitizedName != name)
            {
                sb.AppendLine($"    /// <summary>Original ClickHouse value: '{name}'</summary>");
            }
            sb.AppendLine($"    {sanitizedName} = {value}{comma}");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static List<(string Name, int Value)>? ParseEnumDefinition(string typeString)
    {
        var match = EnumDefinitionRegex().Match(typeString);
        if (!match.Success) return null;

        var content = match.Groups[1].Value;
        var members = new List<(string, int)>();

        foreach (Match memberMatch in EnumMemberRegex().Matches(content))
        {
            members.Add((memberMatch.Groups[1].Value, int.Parse(memberMatch.Groups[2].Value)));
        }

        return members.Count > 0 ? members : null;
    }

    private static string SanitizeEnumMemberName(string name)
    {
        // Replace invalid characters with underscore
        var sanitized = InvalidIdentifierRegex().Replace(name, "_");

        // Ensure doesn't start with digit
        if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
            sanitized = "_" + sanitized;

        // Ensure not a C# keyword
        if (IsCSharpKeyword(sanitized))
            sanitized = "@" + sanitized;

        return string.IsNullOrEmpty(sanitized) ? "_" : sanitized;
    }

    private static bool IsCSharpKeyword(string name) =>
        name is "default" or "new" or "null" or "true" or "false"
            or "in" or "out" or "ref" or "class" or "struct" or "enum"
            or "public" or "private" or "protected" or "internal";

    [GeneratedRegex(@"^Enum(?:8|16)\((.+)\)$", RegexOptions.IgnoreCase)]
    private static partial Regex EnumDefinitionRegex();

    [GeneratedRegex(@"'([^']+)'\s*=\s*(-?\d+)")]
    private static partial Regex EnumMemberRegex();

    [GeneratedRegex(@"[^a-zA-Z0-9_]")]
    private static partial Regex InvalidIdentifierRegex();
}
