# Phase Ordering

ClickHouse DDL has strict dependency constraints that differ from traditional databases. A materialized view depends on its source table existing. A projection depends on its parent table. An index cannot be added in the same ALTER TABLE as a new column. EF.CH automatically reorders migration operations into phases to respect these constraints.

## Why Order Matters

Consider a migration that creates a table, a materialized view, and a projection:

1. The materialized view's SELECT references the source table -- the table must exist first
2. A projection references columns on a table -- the column must exist before the projection
3. Dropping a materialized view must happen before dropping its source table

EF Core generates operations in model-differ order, which does not guarantee ClickHouse-compatible ordering. The `ClickHouseMigrationsSplitter` reorders operations into dependency-correct phases.

## Phase Order

Operations are classified into 9 phases, processed sequentially:

| Phase | Operations | Rationale |
|-------|-----------|-----------|
| 1 | Drop projections, drop indexes | Remove dependents before modifying tables |
| 2 | Drop materialized views, drop dictionaries | Topo-sorted: dependents dropped before their sources |
| 3 | Drop regular tables | Safe after dependent views are removed |
| 4 | Create regular tables | Tables must exist before views that reference them |
| 5 | Add columns | New columns must exist before MVs that reference them |
| 6 | Create materialized views, create dictionaries | Topo-sorted: sources created before their dependents |
| 7 | Alter columns, drop columns, rename columns | Safe after dependent MVs are created |
| 8 | Create indexes | Indexes are added after all column changes |
| 9 | Add projections, materialize projections | Projections depend on final table structure |

## Topological Sorting Within Phases

Phases 2 and 6 contain materialized views and dictionaries that may depend on each other. Within these phases, EF.CH uses Kahn's algorithm for topological sorting:

- **Phase 2 (drops)**: Dependents are dropped before their sources. If view B reads from view A, B is dropped first.
- **Phase 6 (creates)**: Sources are created before their dependents. If view B reads from table A, A is created first.

Dependencies are detected from:
- `MaterializedViewSource` annotations (the source table name)
- `DictionarySource` annotations (the source table name)
- SQL table references parsed from `MaterializedViewQuery` annotations

## Example

Given a migration with these operations (in model-differ order):

1. CreateTable `DailySummary` (materialized view)
2. CreateTable `Orders` (regular table)
3. CreateIndex `IX_Orders_Category`
4. AddProjection `proj_daily`

After phase ordering:

| Step | Phase | Operation |
|------|-------|-----------|
| 1 | 4 - Create tables | CreateTable `Orders` |
| 2 | 6 - Create MVs | CreateTable `DailySummary` (materialized view, depends on Orders) |
| 3 | 8 - Create indexes | CreateIndex `IX_Orders_Category` |
| 4 | 9 - Add projections | AddProjection `proj_daily` |

## Annotations for Classification

The scaffolder enriches migration operations with annotations so the splitter can correctly classify them:

| Annotation | Purpose |
|-----------|---------|
| `ClickHouse:MaterializedView` | Marks a CreateTable/DropTable as a materialized view |
| `ClickHouse:MaterializedViewSource` | The source table name for the view |
| `ClickHouse:MaterializedViewQuery` | The SELECT query for parsing table references |
| `ClickHouse:Dictionary` | Marks a CreateTable/DropTable as a dictionary |
| `ClickHouse:DictionarySource` | The source table name for the dictionary |

For drop operations, annotations are copied from the previous model snapshot so the splitter knows which dropped tables were views or dictionaries.

## Cycle Handling

If a circular dependency is detected (which should not occur in valid ClickHouse schemas), the splitter falls back to the original operation order for the remaining items after processing all resolvable dependencies.

> **Note:** Phase ordering is automatic. You do not need to manually order operations when writing custom migrations. The splitter processes all operations generated by `Add-Migration` or added via `migrationBuilder` extensions.

## See Also

- [Split Migrations](split-migrations.md) -- how operations are separated into individual files
- [Migrations Overview](overview.md) -- general migration workflow
- [Projection Operations](projection-operations.md) -- operations handled in phase 9
