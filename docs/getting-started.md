# Getting Started with EF.CH

This guide will help you set up EF.CH and create your first ClickHouse-backed application.

## Prerequisites

- **.NET 8.0 SDK** or later
- **ClickHouse** server (local, Docker, or cloud)
- Basic familiarity with Entity Framework Core

## Installation

Add the EF.CH package to your project:

```bash
dotnet add package EF.CH
```

## Setting Up ClickHouse

### Option 1: Docker (Recommended for Development)

```bash
docker run -d \
  --name clickhouse \
  -p 8123:8123 \
  -p 9000:9000 \
  clickhouse/clickhouse-server:latest
```

### Option 2: docker-compose

Create a `docker-compose.yml`:

```yaml
services:
  clickhouse:
    image: clickhouse/clickhouse-server:latest
    ports:
      - "8123:8123"
      - "9000:9000"
    volumes:
      - clickhouse-data:/var/lib/clickhouse

volumes:
  clickhouse-data:
```

Run with `docker-compose up -d`.

### Option 3: ClickHouse Cloud

Sign up at [clickhouse.cloud](https://clickhouse.cloud/) and use your connection string.

## Your First Application

### 1. Create a New Project

```bash
dotnet new console -n MyClickHouseApp
cd MyClickHouseApp
dotnet add package EF.CH
dotnet add package Microsoft.EntityFrameworkCore.Design
```

### 2. Define Your Entity

```csharp
public class Event
{
    public Guid Id { get; set; }
    public DateTime Timestamp { get; set; }
    public string EventType { get; set; } = string.Empty;
    public string UserId { get; set; } = string.Empty;
    public string? Payload { get; set; }
}
```

### 3. Create Your DbContext

```csharp
using EF.CH.Extensions;
using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    public DbSet<Event> Events => Set<Event>();

    protected override void OnConfiguring(DbContextOptionsBuilder options)
    {
        options.UseClickHouse("Host=localhost;Database=myapp");
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Event>(entity =>
        {
            // Every ClickHouse table needs an engine with ORDER BY
            entity.HasKey(e => e.Id);
            entity.UseMergeTree(x => new { x.Timestamp, x.Id });

            // Optional: partition by month for better performance
            entity.HasPartitionByMonth(x => x.Timestamp);
        });
    }
}
```

### 4. Use It

```csharp
using Microsoft.EntityFrameworkCore;

await using var context = new AppDbContext();

// Create the database and tables
await context.Database.EnsureCreatedAsync();

// Insert data
context.Events.Add(new Event
{
    Id = Guid.NewGuid(),
    Timestamp = DateTime.UtcNow,
    EventType = "page_view",
    UserId = "user-123",
    Payload = "{\"page\": \"/home\"}"
});
await context.SaveChangesAsync();

// Query data
var recentEvents = await context.Events
    .Where(e => e.Timestamp > DateTime.UtcNow.AddHours(-1))
    .OrderByDescending(e => e.Timestamp)
    .Take(100)
    .ToListAsync();

foreach (var evt in recentEvents)
{
    Console.WriteLine($"{evt.Timestamp}: {evt.EventType} by {evt.UserId}");
}
```

## Connection String

The connection string format follows ClickHouse.Driver conventions:

```
Host=localhost;Port=8123;Database=mydb;Username=default;Password=
```

Common parameters:

| Parameter | Description | Default |
|-----------|-------------|---------|
| `Host` | ClickHouse server hostname | `localhost` |
| `Port` | HTTP port | `8123` |
| `Database` | Database name | `default` |
| `Username` | Authentication user | `default` |
| `Password` | Authentication password | (empty) |
| `UseServerTimezone` | Use server's timezone | `false` |
| `Compression` | Enable compression | `true` |

## Using EF Core Migrations

EF.CH supports EF Core migrations for schema management:

```bash
# Add the EF Core tools if you haven't already
dotnet tool install --global dotnet-ef

# Create a migration
dotnet ef migrations add InitialCreate

# Apply the migration
dotnet ef database update
```

Or apply migrations in code:

```csharp
await context.Database.MigrateAsync();
```

## Project Structure

A typical project structure:

```
MyClickHouseApp/
├── Program.cs
├── AppDbContext.cs
├── Entities/
│   ├── Event.cs
│   └── User.cs
├── Migrations/
│   └── (generated by EF Core)
└── MyClickHouseApp.csproj
```

## Configuration Options

Configure the provider in `OnConfiguring` or via dependency injection:

```csharp
// Option 1: In DbContext
protected override void OnConfiguring(DbContextOptionsBuilder options)
{
    options.UseClickHouse("Host=localhost;Database=myapp", clickHouse =>
    {
        clickHouse.CommandTimeout(60);  // Query timeout in seconds
        clickHouse.MaxBatchSize(10000); // Batch insert size
    });
}

// Option 2: With DI
services.AddDbContext<AppDbContext>(options =>
    options.UseClickHouse(Configuration.GetConnectionString("ClickHouse")));
```

## Next Steps

- Read [ClickHouse Concepts](clickhouse-concepts.md) to understand key differences from traditional databases
- Learn about [Table Engines](engines/overview.md) to choose the right engine for your use case
- Explore [Type Mappings](types/overview.md) for complex types like arrays and maps
- Check out the [samples](../samples/) for complete working examples

## Troubleshooting

### "Cannot connect to ClickHouse"

1. Verify ClickHouse is running: `curl http://localhost:8123/ping`
2. Check the port (HTTP is 8123, native is 9000)
3. Verify network access if using Docker or remote server

### "Table engine is not specified"

Every table needs an engine. Add the engine configuration:

```csharp
entity.UseMergeTree(x => x.Id);  // At minimum, ORDER BY primary key
```

### "Cannot update entity"

ClickHouse doesn't support row-level UPDATE. Options:
- Use `ReplacingMergeTree` for last-write-wins semantics
- Delete and re-insert the row
- Design for append-only patterns

See [Limitations](limitations.md) for more details.
